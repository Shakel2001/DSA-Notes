Insertion sort is a simple sorting algorithm that builds the final sorted array one element at a time.
It works like sorting playing cards in your hand.
--------------------------------------------------------------------------------------------------------
ðŸ“˜ Logic of the Code:
for (int i = 0; i < n; i++) {
    int j = i;
    while (j > 0 && nums[j - 1] > nums[j]) {
        swap(nums[j - 1], nums[j]);
        j--;
    }
}
--------------------------------------------------------------------------------------------------------
Step-by-Step:
Start from i = 0 to n-1.
For each element, check if it is smaller than the one before it.
If it is, swap it backward until it reaches its correct position.
This way, the left part of the array becomes sorted gradually.

--------------------------------------------------------------------------------------------------------
ðŸ§ª Example Walkthrough:
Letâ€™s sort this array:

nums = [5, 3, 4, 1]
Iterations:
i = 0 â†’ nothing happens ([5, 3, 4, 1])

i = 1 â†’ compare 3 and 5 â†’ swap â†’ [3, 5, 4, 1]

i = 2 â†’ compare 4 and 5 â†’ swap â†’ [3, 4, 5, 1]

i = 3 â†’ 1 < 5 â†’ swap â†’ [3, 4, 1, 5]
â†’ 1 < 4 â†’ swap â†’ [3, 1, 4, 5]
â†’ 1 < 3 â†’ swap â†’ [1, 3, 4, 5]

âœ… Final Sorted Array: [1, 3, 4, 5]
--------------------------------------------------------------------------------------------------------
ðŸ§  Time and Space Complexity:
Case	Time Complexity
Best (sorted)	O(n) âœ…
Average	O(nÂ²) âŒ
Worst	O(nÂ²) âŒ
Space	O(1) âœ… (In-place)
--------------------------------------------------------------------------------------------------------
âœ… Advantages:
Simple and easy to understand
Good for small arrays or nearly sorted arrays
Stable (preserves relative order of equal elements)
--------------------------------------------------------------------------------------------------------
âŒ Disadvantages:
Inefficient on large datasets (O(nÂ²) time)
