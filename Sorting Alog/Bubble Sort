Bubble Sort is a simple sorting algorithm that:
Repeatedly compares adjacent elements,
Swaps them if they are in the wrong order.
After each full pass, the largest element bubbles to the end.
----------------------------------------------------------------------
ðŸ§  Logic of the Code:

for (int i = 0; i < n - 1; i++) {
    for (int j = 0; j < n - i - 1; j++) {
        if (nums[j] > nums[j + 1]) {
            swap(nums[j], nums[j + 1]);
        }
    }
}

----------------------------------------------------------------------
Explanation:
Outer loop (i) tracks how many passes weâ€™ve completed.
Inner loop (j) compares each pair and swaps if needed.
After each pass, the largest unsorted element reaches its correct position.

----------------------------------------------------------------------
ðŸ§ª Example:
Input:

nums = [5, 1, 4, 2]
Step-by-step:
Pass 1:

5 > 1 â†’ swap â†’ [1, 5, 4, 2]

5 > 4 â†’ swap â†’ [1, 4, 5, 2]

5 > 2 â†’ swap â†’ [1, 4, 2, 5]

Pass 2:

1 < 4 â†’ no swap

4 > 2 â†’ swap â†’ [1, 2, 4, 5]

Pass 3:

1 < 2 â†’ no swap

âœ… Final Output: [1, 2, 4, 5]

----------------------------------------------------------------------
ðŸ“ Notes:
Works by repeatedly swapping adjacent elements until the array is sorted.
After i passes, the last i elements are in correct position.

----------------------------------------------------------------------
â±ï¸ Time and Space Complexity:
Case	Time Complexity
Best (sorted)	O(n) âœ… (with optimization)
Average	O(nÂ²) âŒ
Worst	O(nÂ²) âŒ
Space	O(1) âœ… (In-place)

----------------------------------------------------------------------
âœ… Advantages:
Easy to implement
Works well for small or nearly sorted arrays

----------------------------------------------------------------------
âŒ Disadvantages:
Very slow for large arrays
Not suitable for high-performance needs
